#include <iostream>
#include <vector>
using namespace std;
 
void Dijkstra(vector<vector<pair<int, int>>>&, int&);
int main() {
    setlocale(LC_ALL, "Russian");
    //==========================================================//
    // Список смежности (рис. 8)                                //
    // представляет собой вектор векторов пар.                  //
    // Первый элемент пары смежная вершина (в массиве 1-я - 0), //
    // а второй элемент - вес инцидентного ребра                //
    //==========================================================//
    vector<vector<pair<int, int>>> G {
        {{1, 10}, {2, 6}, {3,8}                                             }, // 1
        {{0, 10}, {3, 5}, {4,13}, {6, 11}                               },// 2
        {{0, 6}, {3, 2}, {4, 3}                                              }, // 3
        {{0, 8}, {1, 5}, {2, 2}, {4, 5}, {5, 7}, {6, 12}             }, // 4
        {{1,13}, {2, 3}, {3, 5}, {5, 9}, {8, 12}                      }, // 5
        {{4, 9}, {6, 4}, {3,7},{7, 8}, {8, 10}                         }, // 6
        {{1,11}, {3,12}, {5, 4}, {7, 6}, {8, 16}                     }, // 7
        {{5, 8}, {6, 6}, {8,15}                                            } //8
    };
    int vortex = 0;
    
    Dijkstra(G, vortex);
 
    return 0;
}
 
void Dijkstra(vector<vector<pair<int, int>>> &myG, int &s) {
    // Определяем значение infinity
    const int inf = 2000000000;
    size_t n = myG.size();
    //==========================================================//
    // Определяем три массива:                                  //
    // D - для хранения кратчайших путей в графе от исходной    //
    // P - для хранения промежуточных итогов длин путей         //
    // U - для хранения булевских флагов посещения вершин       //
    //==========================================================//
    vector<size_t> D(n, inf);
    vector<size_t> P(n);
    vector<bool> U(n, false);
    // Исходная вершина (в данном случае первая)
    // s = 0;
    D[s] = 0;
    for (size_t i = 0; i < n; i++) {
        // Определяем уникальное значение стартовой вершины
        // Количество вершин не должно превышать это значение
        size_t v = 1000000000;
        for (size_t j = 0; j < n; j++)
        if (!U[j] && (v == 1000000000 || D[j] < D[v]))
                v = j;
        // Выходим, если встретился хоть один inf,
        // что значит: кратчайших маршрутов больше не найдено
        if (D[v] == inf)
            break;
        // Говорим, что посетили вершину
        U[v] = true;
        // Определяем итераторы по текущему списку
        auto beg = myG[v].begin();
        auto lst = myG[v].end();
        while (beg != lst) {
            auto to = beg -> first;
            auto len = beg -> second;
            // Этот процесс называют "релаксацией", т. е.
            // поиск как можно меньшего пути,
            // что повторяет алгоритм Флойда — Уоршелла
            if (D[v] + len < D[to]) {
                D[to] = D[v] + len;
                P[to] = v;
            }
            beg++;
        }
    }
    // Выводим список кратчайших маршрутов от
    // исходной вершины ко всем остальным:
    for (auto &r : D)
        cout << r << " ";
    cout << endl;
}